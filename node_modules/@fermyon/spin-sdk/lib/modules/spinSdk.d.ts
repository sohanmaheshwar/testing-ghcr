/// <reference types="node" />
import { router, routerType } from "./router";
interface SpinConfig {
    get(arg0: string): string;
}
interface KvStore {
    delete: (key: string) => void;
    exists: (key: string) => boolean;
    get: (key: string) => ArrayBuffer | null;
    getJson: (key: string) => any;
    getKeys: () => Array<string>;
    set: (key: string, value: ArrayBuffer | string) => void;
    setJson: (key: string, value: any) => void;
}
type SqliteParam = number | string | ArrayBuffer;
type SqliteValue = null | number | string | ArrayBuffer;
type SqliteRow = Record<string, SqliteValue>;
interface SqliteReturn {
    columns: string[];
    rows: SqliteRow[];
}
interface SqliteStore {
    execute: (query: string, params: SqliteParam[]) => SqliteReturn;
}
type RdbmsParam = null | boolean | string | number | ArrayBuffer;
interface RdbmsReturn {
    columns: string[];
    rows: [
        [
            RdbmsParam
        ]
    ];
}
interface InferencingOptions {
    maxTokens?: number;
    repeatPenalty?: number;
    repeatPenaltyLastNTokenCount?: number;
    temperature?: number;
    topK?: number;
    topP?: number;
}
interface InternalInferencingOptions {
    max_tokens?: number;
    repeat_penalty?: number;
    repeat_penalty_last_n_token_count?: number;
    temperature?: number;
    top_k?: number;
    top_p?: number;
}
interface InferenceUsage {
    promptTokenCount: number;
    generatedTokenCount: number;
}
interface InferenceResult {
    text: string;
    usage: InferenceUsage;
}
interface EmbeddingUsage {
    promptTokenCount: number;
}
interface EmbeddingResult {
    embeddings: Array<Array<number>>;
    usage: EmbeddingUsage;
}
/** @deprecated*/
interface SpinSdk {
    utils: {
        toBuffer: (arg0: ArrayBufferView) => Buffer;
    };
    Router: () => routerType;
    config: SpinConfig;
    redis: {
        execute: (address: string, command: string, args: Array<ArrayBuffer | bigint>) => undefined | string | bigint | ArrayBuffer;
        get: (address: string, key: string) => ArrayBuffer;
        incr: (address: string, key: string) => bigint;
        publish: (address: string, channel: string, value: ArrayBuffer) => undefined;
        set: (address: string, key: string, value: ArrayBuffer) => undefined;
        del: (address: string, key: Array<string>) => bigint;
        sadd: (address: string, key: string, values: Array<string>) => bigint;
        smembers: (address: string, key: string) => Array<string>;
        srem: (address: string, key: string, values: Array<string>) => bigint;
    };
    /**
     * Object that allows access to the Spin Key-Value Store
     */
    kv: {
        /**
         *
         * @param name - The name of the KV store to open
         * @returns A KV store handle
         */
        open: (name: string) => KvStore;
        /**
         * @returns The handle to the default KV store
         */
        openDefault: () => KvStore;
    };
    mysql: {
        execute: (address: string, statement: string, params: RdbmsParam[]) => void;
        query: (address: string, statement: string, params: RdbmsParam[]) => RdbmsReturn;
    };
    pg: {
        execute: (address: string, statement: string, params: RdbmsParam[]) => void;
        query: (address: string, statement: string, params: RdbmsParam[]) => RdbmsReturn;
    };
    sqlite: {
        open: (name: string) => SqliteStore;
        openDefault: () => SqliteStore;
    };
    llm: {
        infer: (model: InferencingModels | string, prompt: string) => InferenceResult;
        inferWithOptions: (model: InferencingModels | string, prompt: string, options: InternalInferencingOptions) => InferenceResult;
        generateEmbeddings: (model: EmbeddingModels | string, sentences: Array<string>) => EmbeddingResult;
    };
}
interface HttpResponse {
    status: number;
    headers?: Record<string, string>;
    body?: ArrayBuffer | string | Uint8Array;
}
declare class ResponseBuilder {
    response: HttpResponse;
    statusCode: number;
    constructor();
    getHeader(key: string): string | null;
    header(key: string, value: string): this;
    status(status: number): this;
    body(data: ArrayBuffer | Uint8Array | string): this;
}
declare global {
    const __internal__: {
        spin_sdk: SpinSdk;
    };
}
/**  features
 */
/** @deprecated */
declare const spinSdk: SpinSdk;
declare enum InferencingModels {
    Llama2Chat = "llama2-chat",
    CodellamaInstruct = "codellama-instruct"
}
declare enum EmbeddingModels {
    AllMiniLmL6V2 = "all-minilm-l6-v2"
}
declare const Llm: {
    infer: (model: InferencingModels | string, prompt: string, options?: InferencingOptions) => InferenceResult;
    generateEmbeddings: (model: EmbeddingModels | string, text: Array<string>) => EmbeddingResult;
};
declare const Config: SpinConfig;
declare const Redis: {
    execute: (address: string, command: string, args: Array<ArrayBuffer | bigint>) => undefined | string | bigint | ArrayBuffer;
    get: (address: string, key: string) => ArrayBuffer;
    incr: (address: string, key: string) => bigint;
    publish: (address: string, channel: string, value: ArrayBuffer) => undefined;
    set: (address: string, key: string, value: ArrayBuffer) => undefined;
    del: (address: string, key: Array<string>) => bigint;
    sadd: (address: string, key: string, values: Array<string>) => bigint;
    smembers: (address: string, key: string) => Array<string>;
    srem: (address: string, key: string, values: Array<string>) => bigint;
};
declare const Kv: {
    open: (name: string) => KvStore;
    openDefault: () => KvStore;
};
declare const Mysql: {
    execute: (address: string, statement: string, params: RdbmsParam[]) => void;
    query: (address: string, statement: string, params: RdbmsParam[]) => RdbmsReturn;
};
declare const Pg: {
    execute: (address: string, statement: string, params: RdbmsParam[]) => void;
    query: (address: string, statement: string, params: RdbmsParam[]) => RdbmsReturn;
};
declare const Sqlite: {
    open: (name: string) => SqliteStore;
    openDefault: () => SqliteStore;
};
export { spinSdk, SpinSdk };
export { Config, Redis, Kv, router, Mysql, Pg, Sqlite, Llm, InferencingModels, EmbeddingModels, InferencingOptions, ResponseBuilder };
